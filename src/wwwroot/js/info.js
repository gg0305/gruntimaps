/*

Copyright 2016, 2017, 2018 GIS People Pty Ltd

This file is part of GruntiMaps.

GruntiMaps is free software: you can redistribute it and/or modify it under 
the terms of the GNU Affero General Public License as published by the Free
Software Foundation, either version 3 of the License, or (at your option) any
later version.

GruntiMaps is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
A PARTICULAR PURPOSE. See the GNU Affero General Public License for more 
details.

You should have received a copy of the GNU Affero General Public License along
with GruntiMaps.  If not, see <https://www.gnu.org/licenses/>.

*/
$(".validate").on('click', function(event) {
        var layerId = event.target.id;
        console.log("validate %s called", layerId);
        var errors = "";
        $.getJSON(`/api/layers/${layerId}/source`)
        .done(function(source) {
            console.log("source=%o",source);
            $.getJSON(`/api/layers/${layerId}/style`)
            .done(function(style) {
                console.log("style=%o", style);
                $.getJSON(`/api/layers/${layerId}/metadata`)
                .done(function(data) {
                    console.log("data=%o", data);
                    // check that style references to source are correct
                    if (style===null || style.length===0) { 
                        errors += "no style found\n"; 
                        console.log("style not found for service");
                        if (data.tilestats===null || data.tilestats.layerCount === 0) {
                            errors += "no tilesets data so can't generate a style either\n";
                            console.log("no tilestats data available");
                        } else {
                            for (var i = 0; i < data.tilestats.layerCount; i++) {
                                var layerstats = data.tilestats.layers[i];
                                console.log("Layer %s has %i %s geometries and there are %i attributes", layerstats["layer"], layerstats["count"], layerstats["geometry"], layerstats["attributeCount"]);
                            }
                        }
                    } else if (style[0].metadata && style[0].metadata.gruntimaps && style[0].metadata.gruntimaps.autogenerated) {
                        console.log("autogenerated");
                        errors += "autogenerated style";
                    } else
                    {
                        for (let i=0; i<style.length; i++) {
                            const srcMismatch = style[i].source !== source.name;
                            if (srcMismatch) errors += "style source name mismatch\n";
                            console.log("style source name matches source name: %s", srcMismatch ? "FAILED" : "OK");
                            const dataMismatch = style[i]["source-layer"] !== data.vector_layers[0].id;
                            if (dataMismatch) errors += "data source layer name mismatch\n";
                            console.log("data layer name matches source layer name: %s", dataMismatch ? "FAILED" : "OK");
                        }
                    }
                    if (errors === "") { errors = "OK"; }
                    event.target.text = errors;
                });
                });
            });
    });